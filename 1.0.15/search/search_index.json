{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyOSC Documentation","text":"<p>Welcome to the PyOSC documentation! PyOSC is a Python library for working with Open Sound Control (OSC) messages and protocols. This documentation provides an overview of the library's features, installation instructions, and usage examples.</p>"},{"location":"api_reference/","title":"Api Reference","text":""},{"location":"api_reference/#peer","title":"Peer","text":"<pre><code>class Peer(address: str, port: int, mode: OSCModes, framing: OSCFraming, UDP_bind_address: str)\n</code></pre> <ul> <li><code>address</code>: The IP address or hostname of the remote peer.</li> <li><code>port</code>: The port number on which the remote peer is listening.</li> <li><code>mode</code>: The transport mode, either <code>OSCModes.UDP</code> or <code>OSCModes.TCP</code>.</li> <li><code>framing</code>: The OSC framing protocol, <code>OSCFraming.OSC10</code> or <code>OSCFraming.OSC11</code>.</li> <li><code>UDP_bind_address</code>: (Optional) The local IP address to bind the UDP socket for receiving messages. Required if <code>mode</code> is <code>OSCModes.UDP</code>.</li> </ul> <p>Returns a <code>Peer</code> object that can send and receive OSC messages.</p> <p>The <code>Peer</code> object also returns the following attributes:</p> <ul> <li><code>dispatcher</code>: A <code>Dispatcher</code> object responsible for routing incoming messages to the appropriate handlers.</li> </ul>"},{"location":"api_reference/#peer-methods","title":"Methods","text":""},{"location":"api_reference/#method-start_listening","title":"<code>start_listening()</code>","text":"<p><pre><code>peer.start_listening()\n</code></pre> Starts a background thread to listen for incoming OSC messages.</p>"},{"location":"api_reference/#method-send_message","title":"<code>send_message(message: OSCMessage)</code>","text":"<pre><code>peer.send_message(message: OSCMessage)\n</code></pre> <p>Sends an OSC message to the remote peer.</p> <ul> <li><code>message</code>: An <code>OSCMessage</code> object representing the message to be sent.</li> </ul>"},{"location":"api_reference/#method-stop_listening","title":"<code>stop_listening()</code>","text":"<p><pre><code>peer.stop_listening()\n</code></pre> Stops the background thread that listens for incoming OSC messages.</p>"},{"location":"api_reference/#oscmessage","title":"OSCMesssage","text":"<pre><code>class OSCMessage(address: str, args: tuple(OSCArg(value=xxx), ...))\n</code></pre> <ul> <li><code>address</code>: The OSC address pattern for the message (Not to be confused with the Peers IP address).</li> <li><code>args</code>: A tuple of <code>OSCArg</code> objects representing the arguments of the message.</li> </ul>"},{"location":"api_reference/#oscargs","title":"OSCArgs","text":"<pre><code>class OSCArg\n</code></pre> <p>Base class for all OSC argument types. Subclasses include:</p> <ul> <li><code>OSCInt</code></li> <li><code>OSCFloat</code></li> <li><code>OSCString</code></li> <li><code>OSCInt64</code></li> <li><code>OSCTimeTag</code></li> <li><code>OSCDouble</code></li> <li><code>OSCBlob</code></li> <li><code>OSCChar</code></li> <li><code>OSCSymbol</code></li> <li><code>OSCNil</code></li> <li><code>OSCRGBA</code></li> <li><code>OSCMidi</code></li> <li><code>OSCImpulse</code></li> <li><code>OSCArray</code></li> <li><code>OSCFalse</code></li> <li><code>OSCTrue</code></li> </ul>"},{"location":"api_reference/#dispatcher","title":"Dispatcher","text":"<p><pre><code>class Dispatcher()\n</code></pre> The <code>Dispatcher</code> class is responsible for routing incoming OSC messages to the appropriate handler functions based on their address patterns.</p>"},{"location":"api_reference/#dispatcher-methods","title":"Methods","text":""},{"location":"api_reference/#method-add_handler","title":"<code>add_handler(address: str, handler: Callable, validator: Optional)</code>","text":"<p><pre><code>dispatcher.add_handler(address: str, handler: Callable, validator: Optional)\n</code></pre> Registers a handler function for a specific OSC address pattern.</p> <ul> <li><code>address</code>: The OSC address pattern to match.</li> <li><code>handler</code>: A callable function that will be invoked when a message with the specified address is received.</li> <li><code>validator</code>: (Optional) A Pydantic model class used to validate and parse the incoming message.</li> </ul>"},{"location":"api_reference/#method-remove_handler","title":"<code>remove_handler(address: str)</code>","text":"<p><pre><code>dispatcher.remove_handler(address: str)\n</code></pre> Unregisters the handler function for a specific OSC address pattern.</p> <ul> <li><code>address</code>: The OSC address pattern whose handler should be removed.</li> </ul>"},{"location":"api_reference/#method-default_handler","title":"<code>add_default_handler(handler: Callable)</code>","text":"<p><pre><code>dispatcher.add_default_handler(handler: Callable)\n</code></pre> Registers a default handler function that will be invoked when no other registered handlers match the incoming message's address.</p> <ul> <li><code>handler</code>: A callable function that will be invoked for unmatched messages.</li> </ul> <p>Danger</p> <p>The default handler no longer exists in PyOSC as of version 1.0.8. See <code>Default Handler</code> for more information.</p>"},{"location":"api_reference/#method-dispatch","title":"<code>Dispatch(message: OSCMessage)</code>","text":"<p><pre><code>dispatcher.dispatch(message: OSCMessage)\n</code></pre> Not to be called directly, this method is called by a background thread when a message is received. It routes the incoming message to the appropriate handler based on its address.</p> <ul> <li><code>message</code>: An <code>OSCMessage</code> object representing the incoming message.</li> </ul>"},{"location":"api_reference/#callhandler","title":"CallHandler","text":"<p><pre><code>caller = CallHandler(peer)\n</code></pre> The <code>CallHandler</code> class is a specialized handler that facilitates sending OSC messages and waiting for responses</p> <ul> <li><code>peer</code>: A <code>Peer</code> object used to send and receive messages.</li> </ul> <p>Warning</p> <p>The <code>CallHandler</code> will likely change in a future version of PyOSC, and will likely be the initialized as the default handler when a <code>Peer</code> object is created.</p>"},{"location":"api_reference/#callhandler-methods","title":"Methods","text":""},{"location":"api_reference/#method-call","title":"<code>call(message: OSCMessage, return_addr: str, timeout: float, validator: Optional)</code>","text":"<p><pre><code>response = caller.call(\n    message: OSCMessage,\n    return_addr: str,\n    timeout: float,\n    validator: Optional\n)\n</code></pre> Sends an OSC message and waits for a response on a specified return address.</p> <ul> <li><code>message</code>: An <code>OSCMessage</code> object representing the message to be sent.</li> <li><code>return_addr</code>: The OSC address pattern where the response is expected.</li> <li><code>timeout</code>: The maximum time to wait for a response, in seconds.</li> <li><code>validator</code>: (Optional) A Pydantic model class used to validate and parse the incoming response message.</li> <li>Returns: A <code>BaseModel</code> object containing the response message, or <code>None</code> if the timeout is reached without receiving a response.</li> </ul>"},{"location":"api_reference/#response","title":"Response","text":"<p>The response returned by the <code>call</code> method is an instance of the Pydantic model specified by the <code>validator</code> parameter. This model will contain the parsed arguments of the response message, allowing for easy access to the data contained within the OSC message.</p> <p>If no <code>validator</code> is provided, the raw <code>OSCMessage</code> object will be returned.</p>"},{"location":"api_reference/#validators","title":"Validators","text":"<p>Validators are Pydantic models used to validate and parse incoming OSC messages before they are processed by handler functions. They ensure that the messages conform to expected formats and types.</p>"},{"location":"api_reference/#creating-a-validator","title":"Creating a Validator","text":"<p>To create a validator, define a Pydantic model that specifies the expected structure of the OSC message. Each field in the model corresponds to an argument in the OSC message. <pre><code>from pydantic import BaseModel\nfrom pyosc import OSCInt, OSCString\nclass PingResponse(BaseModel):\n    args: tuple[OSCString]\n\n    @property\n    def message(self) -&gt; str:\n        return self.args[0].value\n</code></pre></p> <p>In this example, we define a <code>PingResponse</code> model that expects a single string argument in the OSC message. The <code>message</code> property provides a convenient way to access the string value.</p>"},{"location":"api_reference/#using-a-validator","title":"Using a Validator","text":"<p>When registering a handler with the <code>Dispatcher</code>, you can specify a validator to ensure that incoming messages are validated before being passed to the handler function.</p> <pre><code>peer.dispatcher.add_handler(\"/test/out/ping\", ping_handler, validator=PingResponse)\n</code></pre>"},{"location":"api_reference/#oscmodes","title":"<code>OSCModes</code> Enum","text":"<p>There are two transport modes supported by OSC, and by extension PyOSC.</p> <ul> <li><code>OSCModes.UDP</code>: User Datagram Protocol, a connectionless protocol that is faster but does not guarantee message delivery.</li> <li><code>OSCModes.TCP</code>: Transmission Control Protocol, a connection-oriented protocol that guarantees message delivery but is slower due to the overhead of establishing and maintaining a connection.</li> </ul> <p>TCP is generally preferred for applications where message delivery is critical, while UDP may be suitable for applications that require low latency and can tolerate some message loss. TCP is also simpler to work with, as you know when a connection is established, and you don't have to manage ports for receiving messages separately.</p>"},{"location":"api_reference/#oscframing","title":"<code>OSCFraming</code> Enum","text":"<p>OSC messages can be framed in different ways depending on the version of the OSC protocol being used. - <code>OSCFraming.OSC10</code>: The original OSC 1.0 framing protocol. - <code>OSCFraming.OSC11</code>: The updated OSC 1.1 framing protocol,</p> <p>The two versions of the specification can be found here:</p> <ul> <li>OSC 1.0 Specification</li> <li>OSC 1.1 Specification</li> </ul> <p>When using version 1.1 and UDP transport, messages are actually exactly the same as version 1.0, however when using TCP transport, this are a little bit different.</p>"},{"location":"contributing/","title":"Contributing to PyOSC","text":"<p>Contributors to this project are more than welcome, weather you have just started or are experienced in open source contributions, I am happy for you to contribute to this project. However, I do have some requirements.</p> <ul> <li>Be nice please, I want this to be a project that doesn't have a dark doomy cloud of \"but the maintainers are hard to work with\".</li> <li>Please make your code clean, easy to understand, and make every solution the best solution YOU can come up with. I don't care that it's the best, I care that you tried.</li> <li>Please explain your changes, when you make them, and why. I'm not a programmer by trade, nor am I particularly good at it, please please explain in your PRs what you have done, and why.</li> <li>My AI policy is simple, don't make it effect the project, or the maintainers of this project. If your changes make it hard to maintain this project going into the future, or otherwise compromises the integrity of this project, please think about what you are committing.</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#version-1015-current","title":"Version 1.0.15 (Current)","text":"<p>The initial release covers the core functionality needed for OSC communication in Python.</p> <p>What's included:</p> <ul> <li>Basic OSC message handling and dispatch</li> <li>TCP/UDP network communication via Peer</li> <li>CallHandler for request-response patterns</li> <li>Cross-platform support (Windows, macOS, Linux)</li> <li>Error handling and logging</li> <li>API documentation and tutorials</li> <li>Unit tests for critical components</li> <li>Time-tagged message scheduling</li> </ul>"},{"location":"roadmap/#upcoming-features-may-include-breaking-changes","title":"Upcoming Features (May include breaking changes)","text":"<p>Handler improvements</p> <ul> <li>Streamline CallHandler so it's created as the default handler when Peer is initialized. This will reduce boilerplate but may require some refactoring of the Peer object.</li> <li>Replace the current default handler with a default CallHandler that can be customized or overwritten.</li> </ul> <p>Dispatcher enhancements</p> <ul> <li>Add support for exclusions in dispatch handlers, so we don't need hacky solutions with subsequent handlers that do nothing.</li> </ul> <p>Improved Error Handling - Implement more robust error handling and logging throughout the library, especially in network communication and message parsing. - Provide clearer errors on validation failures to make it easier to diagnose issues with message formats and</p>"},{"location":"roadmap/#future","title":"Future","text":"<p>Subscription system</p> <ul> <li>Implement pub/sub patterns for OSC messages</li> <li>Allow clients to subscribe to specific address patterns</li> </ul> <p>Other potential features</p> <ul> <li>Bundle support for batched messages</li> <li>Connection pooling and multiplexing</li> <li>Better debugging and introspection tools</li> </ul>"},{"location":"roadmap/#contributing","title":"Contributing","text":"<p>See CONTRIBUTING.MD for how to propose features or submit improvements.</p>"},{"location":"getting-started/first-steps/","title":"First Steps","text":"<p>This is a quick guide to get you started with PyOSC, you should follow the API docs and examples for more detailed information on how to use the library.</p>"},{"location":"getting-started/first-steps/#sending-your-first-osc-message","title":"Sending Your First OSC Message","text":"<p>To send your first OSC message using PyOSC, you can use the following example code:</p> <p><pre><code>from pyosc import Peer, OSCMessage, OSCModes, OSCFraming, OSCInt, OSCString\n\npeer = Peer(\n    \"127.0.0.1\",\n    3032,\n    mode=OSCModes.TCP,\n    framing=OSCFraming.OSC11,\n)\nmessage = OSCMessage(\n    address=\"/test/message\",\n    args=(\n        OSCInt(value=42),\n        OSCString(value=\"Hello_World!\"),\n    )\n)\npeer.send_message(message)\n</code></pre> The above example creates a <code>Peer</code> object, using the TCP mode, and framing from OSC version 1.1. It then constructs a <code>OSCMessage</code> with the address <code>/test/message</code> and two arguments:</p> <ol> <li>An integer with the value <code>42</code></li> <li>A string with the value <code>Hello_World!</code></li> </ol> <p>Finally, it sends the message using the <code>send_message</code> method, of the <code>Peer</code> object.</p>"},{"location":"getting-started/installation/","title":"Introduction to PyOSC","text":"<p>This is the documentation for PyOSC, a library for Pytthon to handle the transport of OSC messages and Bundles over a network. It depends on <code>oscparser</code> to parse and serialize OSC messages.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>PyOSC requires Python 3.13 or greater, earlier versions of Python are not supported and will not work.</p>"},{"location":"getting-started/installation/#installation","title":"Installation","text":"<p>PyOSC is available on PyPI, so installation is simple using the following commands:</p> PipPoetry <pre><code>pip install pyopensoundcontrol\n</code></pre> <pre><code>poetry add pyopensoundcontrol\n</code></pre>"},{"location":"getting-started/installation/#basic-usage","title":"Basic Usage","text":"<p>Here is a quick example as to how to send a simple OSC message using PyOSC:</p> <p><pre><code>from pyosc import Peer, OSCMessage, OSCModes, OSCFraming, Dispatcher, OSCInt, OSCString\n\npeer = Peer(\n    \"127.0.0.1\",\n    3032,\n    mode=OSCModes.TCP,\n    framing=OSCFraming.OSC11,\n)\nmessage = OSCMessage(\n    address=\"/test/message\",\n    args=(\n        OSCInt(value=42),\n        OSCString(value=\"Hello\"),\n    )\n)\npeer.send_message(message)\n</code></pre> For more detailed examples and advanced usage, please refer to the subsequent sections of this documentation.</p>"},{"location":"tutorials/call_handler/","title":"Call Handlers","text":"<p>In PyOSC, a <code>CallHandler</code> is a kind of handler that is designed for sending a message and expecting or waiting for a response. This is particularly useful for request-response patterns, where you send a message to a remote peer and want to handle the response in a structured way.</p> <p>They function in a very similar way to dispatch handlers, and actually replace the need for writing a default handler, as the call handler will handle the response for you.</p>"},{"location":"tutorials/call_handler/#creating-a-call-handler","title":"Creating a Call Handler","text":"<p>To create a <code>CallHandler</code>, you need to define a handler function that will process the response message. You can also define a validator function to ensure that the incoming message is of the expected type.</p> <p>In this simple example we will create a call handler, assuming that you have already created a <code>Peer</code> object called <code>peer</code>.</p> <pre><code>from pyosc import CallHandler\n\ncall_handler = CallHandler(peer) #(1)!\npeer.dispatcher.add_default_handler(call_handler) #(2)!\n</code></pre> <ol> <li>The <code>CallHandler</code> is instantiated with the <code>peer</code> object, which allows it to send messages through that peer.</li> <li>The <code>call_handler</code> is registered as the default handler for the <code>peer</code>'s dispatcher. This means that it will handle incoming messages that do not match any other registered handlers.</li> </ol>"},{"location":"tutorials/call_handler/#using-the-call-handler","title":"Using the Call Handler","text":"<p>Once you have created a <code>CallHandler</code>, you can use it to send messages and wait for responses. You can specify a validator to ensure that the response message is of the expected type.</p> <p>Here's an example of how to use the <code>CallHandler</code> to send a message and wait for a response:</p> <pre><code>from pyosc import OSCMessage, OSCString\n\nresponse = call_handler.call(\n    OSCMessage(address=\"/test/ping\", args=(OSCString(value=\"Hello_world!\"),)),\n    return_addr=\"/test/out/ping\",\n    timeout=10.0,\n)  # (1)!\nif response:\n    print(response.message)  # (2)!\n</code></pre> <ol> <li>The <code>call</code> method of the <code>call_handler</code> is used to send an <code>OSCMessage</code> to the address <code>/test/ping</code>, with a string argument. The <code>return_addr</code> parameter specifies the address where the response is expected, and the <code>timeout</code> parameter specifies how long to wait for a response.</li> <li>If a response is received within the timeout period, it is printed to the console.</li> </ol> <p>In this example, we send a ping message to the <code>/test/ping</code> address, and wait for a response on the <code>/test/out/ping</code> address. If a response is received within 10 seconds, it is printed to the console.</p>"},{"location":"tutorials/call_handler/#using-validators","title":"Using Validators","text":"<p>You can also specify a validator when calling a message to ensure that the response message is of the expected type. Here's an example:</p> <pre><code>from pydantic import BaseModel\nfrom pyosc import OSCString\n\nclass PingResponse(BaseModel):\n    args: tuple[OSCString]\n\n    @property\n    def message(self) -&gt; str:\n        return self.args[0].value\n\n\nresponse = call_handler.call(\n    OSCMessage(address=\"/test/ping\", args=(OSCString(value=\"Hello_world!\"),\n    )),\n    validator=PingResponse,  #(1)!\n    return_addr=\"/test/out/ping\",\n    timeout=10.0,\n)\n\nif response:\n    print(response.message) \n</code></pre> <ol> <li>The <code>validator</code> parameter is set to the <code>PingResponse</code> pydantic model, which defines the expected structure of the response message. If the response message does not conform to this model, it will be rejected.</li> </ol> <p>In this example, we define a <code>PingResponse</code> model that specifies the expected structure of the response message. When calling the message, we provide this model as the validator. If the response message conforms to the model, it is printed to the console.</p>"},{"location":"tutorials/call_handler/#examples","title":"Examples","text":"<p>Here is a complete example that demonstrates the use of a <code>CallHandler</code> to send a ping message and handle the response:</p> <pre><code>from pyosc import Peer, OSCMessage, OSCModes, OSCFraming, OSCString\nfrom pydantic import BaseModel\n\npeer = Peer(\n    \"127.0.0.1\",\n    3032,\n    mode=OSCModes.TCP,\n    framing=OSCFraming.OSC11,\n) #(1)!\n\nclass PingResponse(BaseModel):\n    args: tuple[OSCString] #(2)!\n\n    @property\n    def message(self) -&gt; str:\n        return self.args[0].value #(3)!\n\ncall_handler = CallHandler(peer)\nresponse = call_handler.call(\n    OSCMessage(address=\"/test/ping\", args=(OSCString(value=\"Hello_world!\"),\n    )),\n    validator=PingResponse,\n    return_addr=\"/test/out/ping\",\n    timeout=10.0,\n) #(4)!\n\nif response:\n    print(response.message) #(5)!\n\npeer.dispatcher.add_default_handler(call_handler) #(6)!\npeer.start_listening() #(7)!\n</code></pre> <ol> <li>A <code>Peer</code> object is created to manage the network connection.</li> <li>A <code>PingResponse</code> model is defined to specify the expected structure of the response message</li> <li>A property <code>message</code> is defined to extract the string value from the first argument of the response message.</li> <li>A <code>CallHandler</code> is created and used to send a message and wait for a response, with the <code>PingResponse</code> model as the validator.</li> <li>If a response is received, the message is printed to the console.</li> <li>The <code>call_handler</code> is registered as the default handler for the <code>peer</code>'s dispatcher.</li> <li>The <code>peer</code> starts listening for incoming messages.</li> </ol>"},{"location":"tutorials/dispatcher/","title":"The Dispatcher","text":"<p>The <code>Dispatcher</code> object in PyOSC is what routes incoming OSC messages based on their address. It's implementation is simple and efficient, allowing you to easily register handler based on methods, addresses and pydanntic models.</p>"},{"location":"tutorials/dispatcher/#creating-a-dispatcher","title":"Creating a Dispatcher","text":"<p>Dispatchers no longer need to be explicitly created, as they are now automatically initialized when you create a <code>Peer</code> object. However, if you need to create one manually, you can do so like this:</p> <pre><code>from pyosc import Dispatcher\n\ndispatcher = Dispatcher()\n</code></pre>"},{"location":"tutorials/dispatcher/#registering-handlers","title":"Registering Handlers","text":""},{"location":"tutorials/dispatcher/#default-handler","title":"The Default Handler","text":"<p>In PyOSC handlers are registed by the address for which they are handling messages for. There is only one dispatch handler that doesn't have an address assigned to it, and that is the <code>default handler</code>, which is called when no other handlers match the incoming message's address.</p> <p>Let's make a simple example, that registers a default handler, and prints the message. The default <code>validator</code> will accept all OSCMessages.</p> <p>We will assume you have already created a <code>Peer</code> object called <code>peer</code>.</p> <pre><code>def default_handler(message):#(1)!\n    print(f\"Received a message on address:{message.address} with args: {message.args}\") #(2)!\n\npeer.dispatcher.add_default_handler(default_handler) #(3)!\n</code></pre> <ol> <li>The <code>default_handler</code> function is defined to be parsed a single parameter, <code>message</code>, which is expected to be an <code>OSCMessage</code> object.</li> <li>Inside the handler, we print out the address and arguments of the received message.</li> <li>The <code>default_handler</code> function is registered as the default handler using the <code>add_default_handler</code> method of the <code>dispatcher</code> attribute of the <code>peer</code> object.</li> </ol> <p>To receive messages, simply call the <code>start_listening</code> method on the <code>Peer</code> object:</p> <pre><code>peer.start_listening()\n</code></pre> <p>Here is a full example:</p> <pre><code>from pyosc import Peer, OSCMessage, OSCModes, OSCFraming\n\npeer = Peer(\n    \"127.0.0.1\",\n    3032,\n    mode=OSCModes.TCP,\n    framing=OSCFraming.OSC11,\n)\n\ndef default_handler(message):\n    print(f\"Received a message on address:{message.address} with args: {message.args}\")\n\npeer.dispatcher.add_default_handler(default_handler)\npeer.start_listening()\n</code></pre> <p>Danger</p> <p>Default handlers like this no longer exist in the latest version of this library. The same functionality can be achieved by registering a handler with the address of <code>/*</code>. This is to achieve a more consistent and intuitive API, as well as to allow for multiple handlers that match all addresses. I left this part of the documentation in because it makes it easier to understand how the libruary works. This section however will be removed in a future version of the documentation, to reflect the changes in the library.</p>"},{"location":"tutorials/dispatcher/#handlers","title":"Registering Address-Specific Handlers","text":"<p>In addition to the default handler, you can register handlers for specific OSC addresses. This allows you to drop or ignore messages from certain addresses, as well as process information from others.</p> <p>Here's an example of what a handler specific addresss might look like:</p> <pre><code>def ping_handler(message): #(1)!\n    print(f\"Received a ping message! {message.args}\") #(2)!\n\npeer.dispatcher.add_handler(\"/test/out/ping\", ping_handler) #(3)!\n</code></pre> <ol> <li>The <code>ping_handler</code> function is defined to handle messages sent to the <code>/test/out/ping</code> address.</li> <li>Inside the handler, we print out the arguments of the received ping message.</li> <li>The <code>ping_handler</code> function is registered to handle messages sent to the <code>/test/out/ping</code> address using the <code>add_handler</code> method of the <code>dispatcher</code> attribute of the <code>peer</code> object.</li> </ol> <p>Dispatch handlers can be registered and destroyed at any time, this is because when a message is received, the dispatcher checks against it's list of handlers to see if any match the incoming message's address. As long as the handler is registered when the message arrives, it will be called.</p>"},{"location":"tutorials/dispatcher/#validators","title":"Validators","text":"<p>When registering handlers, you can also provide an optional <code>validator</code>. A validator is a pydantic model that is used to validate incoming messages before they are passed to the handler. If the message does not conform to the validator, it will be rejected and not processed by the handler.</p> <p>Here's an example of registering a handler with a validator:</p> <pre><code>from pydantic import BaseModel #(1)!\n\nclass PingResponse(BaseModel): #(2)!\n    args: tuple[OSCString]\n\n    @property\n    def message(self) -&gt; str:\n        return self.args[0].value #(3)!\n\ndef ping_handler(message: PingResponse): #(4)!\n    print(f\"Received a ping message with response: {message.message}\")\n\npeer.dispatcher.add_handler(\"/test/out/ping\", ping_handler, validator=PingResponse) #(5)!\n</code></pre> <ol> <li>We import <code>BaseModel</code> from the <code>pydantic</code> library to create a validator model.</li> <li>We define a <code>PingResponse</code> model that specifies the expected structure of the incoming message</li> <li>We define a property <code>message</code> that extracts the string value from the first argument of the message.</li> <li>The <code>ping_handler</code> function is defined to accept a <code>PingResponse</code> object, which will be validated before being passed to the handler.</li> <li>The <code>ping_handler</code> function is registered to handle messages sent to the <code>/test/out/ping</code> address, this time with the <code>PingResponse</code> model as its validator.</li> </ol>"},{"location":"tutorials/dispatcher/#examples","title":"Examples","text":"<p>Here is a complete example that demonstrates the use of a dispatcher with both a default handler and an address-specific handler with a validator:</p> <pre><code>from pyosc import Peer, OSCMessage, OSCModes, OSCFraming, OSCString\nfrom pydantic import BaseModel\n\npeer = Peer(\n    \"127.0.0.1\",\n    3032,\n    mode=OSCModes.TCP,\n    framing=OSCFraming.OSC11,\n) #(1)!\n\nclass PingResponse(BaseModel):\n    args: tuple[OSCString] #(2)!\n\n    @property\n    def message(self) -&gt; str:\n        return self.args[0].value #(3)!\n\n\ndef default_handler(message):\n    with open(\"messages.log\", \"a\") as log_file:\n        log_file.write(f\"Received a message on address:{message.address} with args: {message.args}\\n\") #(4)!\n\ndef ping_handler(message: PingResponse):\n    print(f\"Received a ping message with response: {message.message}\") #(7)!\n\npeer.dispatcher.add_default_handler(default_handler)\npeer.dispatcher.add_handler(\"/test/out/ping\", ping_handler, validator=PingResponse) #(5)!\npeer.start_listening() #(6)!\n</code></pre> <ol> <li>A <code>Peer</code> object is created to handle OSC messages over TCP on localhost at port 3032.</li> <li>A <code>PingResponse</code> pydantic model is defined to validate incoming ping messages.</li> <li>A property <code>message</code> is defined to extract the string value from the first argument of</li> <li>The <code>default_handler</code> function logs all received messages to a file named <code>messages.log</code>.</li> <li>The <code>ping_handler</code> function is registered to handle messages sent to the <code>/test/out/ping</code> address, with the <code>PingResponse</code> model as its validator.</li> <li>The <code>start_listening</code> method is called on the <code>Peer</code> object to begin receiving messages.</li> <li>The <code>ping_handler</code> function prints the response message when a valid ping message is received.</li> </ol>"},{"location":"tutorials/message/","title":"Sending an OSC Message","text":"<p>Here I'll explain how to send a simple OSC message, aswell as breaking down the code to explain how it works.</p> <p>In this example I will assume you have already initialized a <code>Peer</code> object called <code>peer</code>, if you need help with this please refer to the Peer Object Tutorial. <pre><code>message = OSCMessage(\n    address=\"/test/message\", #(1)!\n    args=(\n        OSCInt(value=42), #(2)!\n        OSCString(value=\"Hello_World!\") #(3)!\n    )\n)\n\npeer.send_message(message) #(4)!\n</code></pre></p> <ol> <li>The <code>address</code> parameter specifies the OSC address pattern for the message. In this case, the message is being sent to the address <code>/test/message</code>.</li> <li>The first argument in the <code>args</code> tuple is an <code>OSCInt</code> object with a value of <code>42</code>. This represents a 32-bit integer argument in the OSC message.</li> <li>The second argument in the <code>args</code> tuple is an <code>OSCString</code> object with a value of <code>Hello_World!</code>. This represents a string argument in the OSC message.</li> <li>The <code>send_message</code> method of the <code>Peer</code> object is called with the constructed <code>OSCMessage</code> object as an argument. This sends the OSC message to the specified address with the provided arguments.</li> </ol> <p>Here is the example from before, where we send a simple messsage, with two arguments. The arguments are an integer with the value <code>42</code>, and a string with the value <code>Hello_World!</code>.</p> <p>Below is a list of possible argument types that are compatible with OSC messages in PyOSC:</p> <ul> <li><code>OSCInt</code> - Represents a 32-bit integer.</li> <li><code>OSCFloat</code> - Represents a 32-bit floating-point number.</li> <li><code>OSCString</code> - Represents a string.</li> <li><code>OSCInt64</code> - Represents a 64-bit integer.</li> <li><code>OSCTimeTag</code> - Represents an OSC Time Tag.</li> <li><code>OSCDouble</code> - Represents a 64-bit floating-point number.</li> <li><code>OSCBlob</code> - Represents a binary large object (blob).</li> <li><code>OSCChar</code> - Represents a single character.</li> <li><code>OSCSymbol</code> - Represents an OSC symbol.</li> <li><code>OSCNil</code> - Represents a nil value.</li> <li><code>OSCRGBA</code> - Represents an RGBA color value.</li> <li><code>OSCMidi</code> - Represents a MIDI message.</li> <li><code>OSCImpulse</code> - Represents an impulse value.</li> <li><code>OSCArray</code> - Represents an array of OSC arguments.</li> <li>Boolean values are represented using <code>OSCFalse</code> and <code>OSCTrue</code>.</li> </ul>"},{"location":"tutorials/peer/","title":"The Peer Object","text":"<p>The <code>Peer</code> object is the central component of PyOSC, responsible for managing the sending and receiving of OSC messages over a network. It encapsulates the network connection details, message dispatching, and provides an interface for interacting with OSC messages.</p>"},{"location":"tutorials/peer/#initialization","title":"Initialization","text":"<p>To create a <code>Peer</code> object, you need to provide the following parameters:</p> <ul> <li><code>address</code>: The IP address or hostname of the remote peer.</li> <li><code>port</code>: The port number on which the remote peer is listening.</li> <li><code>mode</code>: The transport mode, either <code>OSCModes.UDP</code> or <code>OSCModes.TCP</code>.</li> <li><code>framing</code>: The OSC framing protocol, <code>OSCFraming.OSC10</code> or <code>OSCFraming.OSC11</code>.</li> </ul> <p>Example:</p> TCP exampleUDP example <pre><code>from pyosc import Peer, OSCModes, OSCFraming\npeer = Peer(\n    \"127.0.0.1\",\n    3032,\n    mode=OSCModes.TCP,\n    framing=OSCFraming.OSC11\n)\n</code></pre> <pre><code>from pyosc import Peer, OSCModes, OSCFraming\npeer = Peer(\n    \"127.0.0.1\",\n    8001,\n    mode=OSCModes.UDP,\n    framing=OSCFraming.OSC11,\n    UDP_bind_address=\"127.0.0.1\",\n    UDP_bind_port=8002\n)\n</code></pre> <p>Note</p> <p>When using UDP, it is important to specify the <code>UDP_bind_address</code> and <code>UDP_bind_port</code> to bind the socket for receiving messages.</p>"},{"location":"tutorials/peer/#sending-messages","title":"Sending Messages","text":"<p>To send an OSC message, you must first create an <code>OSCMessage</code> object. Example:</p> <pre><code>from pyosc import OSCMessage, OSCInt, OSCString\nmessage = OSCMessage(\n    address=\"/test/ping\", #(1)!\n    args=(\n        OSCString(value=\"Hello, World!\"), #(2)!\n  ) #(3)!\n )\n</code></pre> <ol> <li>The OSC address to send the message to.</li> <li>Arguments contain a <code>value</code> attribute, which is where the actual value of the argument is stored.</li> <li>The <code>args</code> parameter is a tuple of OSC argument objects, which can be of various types (e.g., <code>OSCInt</code>, <code>OSCString</code>, etc.).</li> </ol>"}]}